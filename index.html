<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mang Baccarat Predictor</title>
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/plotly.js@2.27.0/dist/plotly.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone@7.22.10/babel.min.js"></script>
    <style>
        /* Existing styles unchanged */
        .pattern-scroll {
            overflow-x: auto;
            white-space: nowrap;
            max-width: 100%;
            padding: 10px;
            border: 1px solid #e1e1e1;
            background-color: #f9f9f9;
        }
        .pattern-scroll::-webkit-scrollbar {
            height: 8px;
        }
        .pattern-scroll::-webkit-scrollbar-thumb {
            background-color: #888;
            border-radius: 4px;
        }
        .pattern-circle {
            width: 22px;
            height: 22px;
            display: inline-block;
            margin: 2px;
        }
        .display-circle {
            width: 22px;
            height: 22px;
            display: inline-block;
            margin: 2px;
        }
        @media (max-width: 768px) {
            h1 { font-size: 1.8rem; }
            h3 { font-size: 1.2rem; }
            p, div, span { font-size: 0.9rem; }
            .pattern-circle, .display-circle { width: 16px; height: 16px; }
            button { font-size: 0.9rem; padding: 6px; }
            input, select { font-size: 0.9rem; }
        }
        .error-message {
            color: red;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        // Utility functions (unchanged)
        function normalize(s) { /* ... */ }
        function detectStreak(s) { /* ... */ }
        function buildBigRoad(s) { /* ... */ }
        function buildBigEyeBoy(bigRoadGrid, numCols) { /* ... */ }
        function buildCockroachPig(bigRoadGrid, numCols) { /* ... */ }
        function analyzePairPatterns(recentPairs, result, mode) { /* ... */ }
        function advancedBetSelection(history, mode) { /* ... */ }
        function moneyManagement(bankroll, baseBet, result, previousPrediction, state) { /* ... */ }
        function calculateBankroll(history, baseBet, state) { /* ... */ }
        function calculateWinLossTracker(history, baseBet, aiMode, state) { /* ... */ }

        // Error Boundary Component
        class ErrorBoundary extends React.Component {
            state = { hasError: false, error: null };

            static getDerivedStateFromError(error) {
                return { hasError: true, error };
            }

            render() {
                if (this.state.hasError) {
                    return (
                        <div className="error-message">
                            <h2>Something went wrong.</h2>
                            <p>{this.state.error?.message || 'Unknown error'}</p>
                            <button onClick={() => window.location.reload()}>Reload Page</button>
                        </div>
                    );
                }
                return this.props.children;
            }
        }

        // React Component
        function App() {
            const [state, setState] = React.useState(() => {
                try {
                    const saved = localStorage.getItem('baccaratState');
                    return saved && JSON.parse(saved) ? JSON.parse(saved) : {
                        history: [],
                        initialBankroll: 1000.0,
                        baseBet: 10.0,
                        aiMode: 'Conservative',
                        selectedPatterns: ['Bead Bin', 'Win/Loss'],
                        screenWidth: window.innerWidth,
                        pairTypes: [],
                        previousResult: null,
                        stateHistory: [],
                        stats: { wins: 0, losses: 0, ties: 0, streaks: [], oddPairs: 0, evenPairs: 0 },
                        resultTracker: 0.0,
                        profitLock: 0.0,
                        betAmount: 10.0,
                        consecutiveWins: 0,
                        consecutiveLosses: 0
                    };
                } catch (e) {
                    console.error('Error parsing localStorage:', e);
                    return {
                        history: [],
                        initialBankroll: 1000.0,
                        baseBet: 10.0,
                        aiMode: 'Conservative',
                        selectedPatterns: ['Bead Bin', 'Win/Loss'],
                        screenWidth: window.innerWidth,
                        pairTypes: [],
                        previousResult: null,
                        stateHistory: [],
                        stats: { wins: 0, losses: 0, ties: 0, streaks: [], oddPairs: 0, evenPairs: 0 },
                        resultTracker: 0.0,
                        profitLock: 0.0,
                        betAmount: 10.0,
                        consecutiveWins: 0,
                        consecutiveLosses: 0
                    };
                }
            });

            React.useEffect(() => {
                try {
                    localStorage.setItem('baccaratState', JSON.stringify(state));
                } catch (e) {
                    console.error('Error saving to localStorage:', e);
                }
                const handleResize = () => setState(prev => ({ ...prev, screenWidth: window.innerWidth }));
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, [state]);

            React.useEffect(() => {
                const containers = ['bead-bin-scroll', 'big-road-scroll', 'big-eye-scroll', 'cockroach-scroll', 'win-loss-scroll'];
                containers.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) element.scrollLeft = element.scrollWidth;
                });
            }, [state.history, state.selectedPatterns]);

            const addResult = (result) => {
                console.log('Button clicked: Adding result', result); // Debugging
                try {
                    setState(prev => {
                        const mappedResult = result === 'Player' ? 'P' : result === 'Banker' ? 'B' : 'T';
                        const newStats = { ...prev.stats };
                        newStats[result === 'Tie' ? 'ties' : result === 'Player' ? 'wins' : 'wins']++;
                        const newPairTypes = [...prev.pairTypes];
                        if (prev.previousResult && prev.previousResult !== 'T' && mappedResult !== 'T') {
                            const pairType = prev.previousResult === mappedResult ? 'Even' : 'Odd';
                            newPairTypes.push([prev.previousResult, mappedResult]);
                            newStats[pairType === 'Odd' ? 'oddPairs' : 'evenPairs']++;
                        }
                        const newStateHistory = [...prev.stateHistory, {
                            pairTypes: [...prev.pairTypes],
                            previousResult: prev.previousResult,
                            resultTracker: prev.resultTracker,
                            profitLock: prev.profitLock,
                            betAmount: prev.betAmount,
                            consecutiveWins: prev.consecutiveWins,
                            consecutiveLosses: prev.consecutiveLosses,
                            stats: { ...prev.stats }
                        }];
                        return {
                            ...prev,
                            history: [...prev.history, result],
                            stats: newStats,
                            previousResult: mappedResult,
                            pairTypes: newPairTypes,
                            stateHistory: newStateHistory
                        };
                    });
                } catch (e) {
                    console.error('Error in addResult:', e);
                    alert('Error adding result. Check console for details.');
                }
            };

            const undo = () => {
                console.log('Button clicked: Undo'); // Debugging
                try {
                    setState(prev => {
                        if (!prev.history.length) {
                            alert('No results to undo!');
                            return prev;
                        }
                        if (prev.stateHistory.length) {
                            const lastState = prev.stateHistory[prev.stateHistory.length - 1];
                            return {
                                ...prev,
                                history: prev.history.slice(0, -1),
                                pairTypes: [...lastState.pairTypes],
                                previousResult: lastState.previousResult,
                                resultTracker: lastState.resultTracker,
                                profitLock: lastState.profitLock,
                                betAmount: lastState.betAmount,
                                consecutiveWins: lastState.consecutiveWins,
                                consecutiveLosses: lastState.consecutiveLosses,
                                stats: { ...lastState.stats },
                                stateHistory: prev.stateHistory.slice(0, -1)
                            };
                        }
                        return {
                            ...prev,
                            history: prev.history.slice(0, -1),
                            pairTypes: prev.pairTypes.slice(0, -1),
                            previousResult: prev.history.length > 1 ? (prev.history[prev.history.length - 2] === 'Player' ? 'P' : prev.history[prev.history.length - 2] === 'Banker' ? 'B' : 'T') : null
                        };
                    });
                } catch (e) {
                    console.error('Error in undo:', e);
                    alert('Error undoing result. Check console for details.');
                }
            };

            const resetGame = () => {
                console.log('Button clicked: Reset Game'); // Debugging
                try {
                    const finalBankroll = state.history.length ? calculateBankroll(state.history, state.baseBet, state)[0].slice(-1)[0] : state.initialBankroll;
                    setState({
                        history: [],
                        initialBankroll: Math.max(1.0, finalBankroll + state.profitLock),
                        baseBet: Math.min(10.0, Math.max(1.0, finalBankroll + state.profitLock)),
                        aiMode: 'Conservative',
                        selectedPatterns: ['Bead Bin', 'Win/Loss'],
                        screenWidth: window.innerWidth,
                        pairTypes: [],
                        previousResult: null,
                        stateHistory: [],
                        stats: { wins: 0, losses: 0, ties: 0, streaks: [], oddPairs: 0, evenPairs: 0 },
                        resultTracker: 0.0,
                        profitLock: 0.0,
                        betAmount: Math.min(10.0, Math.max(1.0, finalBankroll + state.profitLock)),
                        consecutiveWins: 0,
                        consecutiveLosses: 0
                    });
                } catch (e) {
                    console.error('Error in resetGame:', e);
                    alert('Error resetting game. Check console for details.');
                }
            };

            const maxDisplayCols = state.screenWidth < 768 ? 10 : 14;

            const renderPattern = (type) => { /* Unchanged renderPattern function */ };
            const renderBankrollChart = () => { /* Unchanged renderBankrollChart function */ };

            return (
                <ErrorBoundary>
                    <div className="container mx-auto p-4">
                        <h1 className="text-3xl font-bold text-center mb-4">Mang Baccarat Predictor</h1>

                        <div className="border rounded p-4 mb-4">
                            <h3 className="text-xl font-semibold">Game Settings</h3>
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                <div>
                                    <label className="block text-sm font-medium">Initial Bankroll</label>
                                    <input
                                        type="number"
                                        value={state.initialBankroll}
                                        onChange={e => setState(prev => ({ ...prev, initialBankroll: parseFloat(e.target.value) || 1.0 }))}
                                        min="1"
                                        step="0.01"
                                        className="w-full p-2 border rounded"
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium">Base Bet (Unit Size)</label>
                                    <input
                                        type="number"
                                        value={state.baseBet}
                                        onChange={e => setState(prev => ({ ...prev, baseBet: Math.min(100, Math.max(1, parseFloat(e.target.value) || 1.0)) }))}
                                        min="1"
                                        max="100"
                                        step="0.01"
                                        className="w-full p-2 border rounded"
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium">AI Mode</label>
                                    <select
                                        value={state.aiMode}
                                        onChange={e => setState(prev => ({ ...prev, aiMode: e.target.value }))}
                                        className="w-full p-2 border rounded"
                                    >
                                        <option>Conservative</option>
                                        <option>Aggressive</option>
                                    </select>
                                </div>
                            </div>
                            <p className="mt-2 text-sm">Money Management: Balanced Progression (increases bet after loss, resets after win, with profit lock at 3x base bet and stop-loss at -10x base bet)</p>
                        </div>

                        <div className="border rounded p-4 mb-4">
                            <h3 className="text-xl font-semibold">Input Game Results</h3>
                            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                <button onClick={() => addResult('Player')} className="bg-blue-500 text-white p-2 rounded hover:bg-blue-600">Player</button>
                                <button onClick={() => addResult('Banker')} className="bg-red-500 text-white p-2 rounded hover:bg-red-600">Banker</button>
                                <button onClick={() => addResult('Tie')} className="bg-green-600 text-white p-2 rounded hover:bg-green-700">Tie</button>
                                <button onClick={undo} disabled={!state.history.length} className="bg-gray-500 text-white p-2 rounded disabled:opacity-50 hover:bg-gray-600">Undo</button>
                            </div>
                        </div>

                        <div className="border rounded p-4 mb-4">
                            <h3 className="text-xl font-semibold">Shoe Patterns</h3>
                            <select
                                multiple
                                value={state.selectedPatterns}
                                onChange={e => setState(prev => ({ ...prev, selectedPatterns: Array.from(e.target.selectedOptions, option => option.value) }))}
                                className="w-full p-2 border rounded mb-4"
                            >
                                {['Bead Bin', 'Big Road', 'Big Eye', 'Cockroach', 'Win/Loss'].map(option => (
                                    <option key={option} value={option}>{option}</option>
                                ))}
                            </select>
                            {state.selectedPatterns.map(pattern => (
                                <div key={pattern} className="mb-4">{renderPattern(pattern)}</div>
                            ))}
                        </div>

                        <div className="border rounded p-4 mb-4">
                            <h3 className="text-xl font-semibold">Prediction</h3>
                            {(() => {
                                try {
                                    const currentBankroll = state.history.length ? calculateBankroll(state.history, state.baseBet, state)[0].slice(-1)[0] : state.initialBankroll;
                                    const [bet, confidence, reason, emotionalTone, patternInsights] = advancedBetSelection(state.history, state.aiMode);
                                    const [recommendedBetSize, , stopLoss] = moneyManagement(currentBankroll, state.baseBet, null, null, state);
                                    if (currentBankroll < Math.max(1.0, state.baseBet)) {
                                        return (
                                            <div>
                                                <p className="text-red-600">Insufficient bankroll to place a bet. Please increase your bankroll or reset the game.</p>
                                                <p><strong>Error</strong>: Bankroll too low.</p>
                                            </div>
                                        );
                                    }
                                    if (stopLoss) {
                                        return (
                                            <div>
                                                <p className="text-red-600">Loss limit reached. Pausing betting until reset.</p>
                                                <p><strong>Error</strong>: Loss limit reached.</p>
                                            </div>
                                        );
                                    }
                                    return (
                                        <div>
                                            {bet === 'Pass' ? (
                                                <p><strong>No Bet</strong></p>
                                            ) : (
                                                <p>
                                                    <strong>Bet</strong>: {bet} | <strong>Confidence</strong>: {confidence.toFixed(2)} | <strong>Bet Size</strong>: ${recommendedBetSize.toFixed(2)} | <strong>Momentum</strong>: {emotionalTone}
                                            </p>
                                        )}
                                        <p><strong>Profit Lock</strong>: ${state.profitLock.toFixed(2)}</p>
                                        <p><strong>Reason:</strong>: {reason}</p>
                                        {patternInsights.length > 0 && (
                                            <div>
                                                <h4 className="text-lg font-semibold">Pattern Insights</h3>
                                                <p>Detected patterns: </p>
                                                <ul className="list-disc pl-5">
                                                    {patternInsights.map((insight, i) => (
                                                        <li key={i}>{insight}</li>
                                                    ))}
                                                </ul>
                                            </div>
                                        )}
                                    </div>
                                );
                                } catch (e) {
                                    console.error('Error in Prediction rendering:', e);
                                    return <p <p className="text-red-500">Error generating prediction. Check console for details.</p>
                                }
                            })()}
                        </div>

                        <div className="border rounded p-4 mb-4">
                            <h3 className="text-xl font-semibold">Balance Progress</h3>
                            {(() => {
                                try {
                                    const [bankrollProgress, betSizes] = calculateBankroll(state.history, state.baseBet, state);
                                    if (!bankrollProgress.length) {
                                        return (
                                            <div>
                                                <p><strong>Balance</strong>: ${state.initialBankroll.toFixed(2)}</p>
                                                <p><strong>Profit Lock</strong>: ${state.profitLock.toFixed(2)}</p>
                                                <p>No balance history yet.</p>
                                            </div>
                                        );
                                    }
                                    return (
                                        <div>
                                            <h4 className="text-lg font-semibold">Balance Progress</h4>
                                            {bankrollProgress.map((val, i) => (
                                                <p key={i}>Hand {i + 1}: ${val.toFixed(2)} | {betSizes[i] > 0 ? `Bet $${amountSizes[i].toFixed(2)}` : 'No Bet'}</p>
                                            ))}
                                            <p><strong>Balance</strong>: ${bankrollProgress[bankrollProgress.length - 1].toFixed(2)}</p>
                                            <p><strong>Profit Lock</strong>: ${state.profitLock.toFixed(2)}</p>
                                            <h4 className="text-lg font-semibold">Balance Progression</h4>
                                            {renderBankrollChart()}
                                        </div>
                                    );
                                } catch (e) {
                                    console.error('Error rendering BankrollProgress:', e);
                                    return <p className="text-red-500">Error generating bankroll chart. Check console.</p>;
                                }
                            })()}
                        </div>

                        <div className="border rounded p-4">
                            <h3 className="text-xl font-semibold">Reset</h3>
                            <button onClick={resetGame} className="bg-blue-600 text-white p-2 rounded hover:bg-blue-400">New Game</button>
                        </div>
                    </div>
                </ErrorBoundary>
            );
        }

        // Render the app
        try {
            ReactDOM.render(<App />, document.getElementById('root'));
        } catch (e) {
            console.error('Error rendering React app:', e);
            document.getElementById('root').innerHTML = 'Failed to load application. Check console for details.';
        }
    </script>
</body>
</html>
